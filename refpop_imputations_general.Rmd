---
title: "Reference_population_imputation"
output: html_document
date: "2023-06-28"
---

## libraries

```{r}
library("data.table")
library("readxl")
library("arrow")
library("ineq")     # inequality measures and example data
library("EnvStats") # for estimation of censored distributions
library(dplyr)
```

## read data tax_records

```{r}
getwd()
tax = read_parquet("/Users/werk/Documents/git_hipnl/data/tax_records/tax_records_latest.parquet")
setDT(tax)
```

## y_trunc tax_income

```{r}
y_trunc = na.omit(tax$income_taxable)
n_tax_records = length(y_trunc)
n_tax_records
```

## read data CBS municipalities and proportions cats

```{r}
CBS_munics <- read_excel("/Users/werk/Documents/git_hipnl/uu_link_dev/analyse_bestanden/n_pers_per_adres_en_stats_cats_2023_06_28_v2.xlsx")
print(CBS_munics$amco)
```

## refpop definitions by categories

refpop_cat1 = huisgezinnen + afzonderlijk_levenden

refpop_cat2 = afzonderlijk_levenden + (huisgezinnen\*2) + overige_leden_huisgezin

refpop_cat3 = afzonderlijk_levenden + huisgezinnen + overige_leden_huisgezin

refpop_proportioneel = x\*cat1 + x\*cat2 + x\*cat3 \`\`\`

## 

## notes: scenarios

*step 1*: refpop

(A) if afzonderlijk_levenden + huisgezinnen + overige_leden_huisgezin known --\> categorical proportional approach based upon pct of categories 1,2,3

    (A) only for munics with tax_records bc pct should be known

(B) beroepsbevolking known --\> how to obtain refpop from this? direct comparison yes/no?

    (A) delta beroepsbevolking & huisgezinnen/afzonderlijk_levenden/overige leden in cbs data

    (B) age composition

(C) bevolking only var known --\> how to obtain refpop from this? direct comparison yes/no?

    (A) delta bevolkings & huisgezinnen/afzonderlijk_levenden/overige leden in cbs data

*step 2*: munics without address info therefore not in file

-   measure proportional beroepsbevolking to huisgezinnen/afzlevenden/overigeleden

-   153 munics ingevoerd; 60 in current file; therefore missing munics without address info

*step 3*: merge refpop with tax records; buiten tax_records taxable range --\> imputeren

### additional notes

bevolking known; otherwise nothing; i.e. Doesburg 1909

-   verkeerd ingevoerd; recheck?

huisgezinnen & huishoudens at times varying n; huishouden \> huisgezinnen

-   huishoudens = huisgezinnen + afz levenden

n_hoofden_huisgezin = n_huisgezinnen

## set NA to zero

```{r}
CBS_varlist_hh <- list(CBS_munics$afzonderlijk_levenden, CBS_munics$huisgezinnen, CBS_munics$overige_leden_huisgezin, CBS_munics$niet_verwant_huizing)

# Function to assign 0 to NA
assign_zero_to_na <- function(x) {
  x[is.na(x)] <- 0
  return(x)
}

# Apply the function to each variable in the list
CBS_varlist_hh <- lapply(CBS_varlist_hh, assign_zero_to_na)

CBS_varlist_hh
```

##refpop for categories and munics

```{r}
refpop_cat1 = CBS_munics$huisgezinnen + CBS_munics$afzonderlijk_levenden

refpop_cat2 = CBS_munics$afzonderlijk_levenden + (CBS_munics$huisgezinnen*2) + CBS_munics$overige_leden_huisgezin

refpop_cat3 = CBS_munics$afzonderlijk_levenden + CBS_munics$huisgezinnen + CBS_munics$overige_leden_huisgezin + CBS_munics$niet_verwant_huizing

refpop_cat1[is.na(refpop_cat1)] <- 0
refpop_cat2[is.na(refpop_cat2)] <- 0
refpop_cat3[is.na(refpop_cat3)] <- 0

refpop_cat1
refpop_cat2
refpop_cat3
```

```{r}
refpop_proportional = CBS_munics$cat1_pct * refpop_cat1 + CBS_munics$cat2_pct * refpop_cat2 + CBS_munics$cat3_pct * refpop_cat3

refpop_proportional[is.na(refpop_proportional)] <- 0

refpop_proportional
```

## add hh vars to CBS_munics data

Nu hebben we de koppeling tussen ieder gemeente-jaar combinatie en het aantal missende personen.

```{r}
CBS_munics_hh <- cbind(CBS_munics,refpop_cat1, refpop_cat2, refpop_cat3, refpop_proportional)

CBS_munics_hh
```

Nu moeten we voor ieder gemeente-jaar imputeren, en dan op de inkomenskolom.

```{r}
# maak tibles van dataframes
tax = tibble(tax)
CBS_munics_hh = tibble(CBS_munics_hh)

# voeg year_mun_id toe voor makkelijkere filtering
CBS_munics_hh["year_mun_id"] = paste0(as.character(CBS_munics_hh$year), "_", gsub(" ", "_", CBS_munics_hh$municipality_cbs))
CBS_munics_hh
```

```{r}
# filter tax dataframe zodat we alleen gemeente-jaar combinaties hebben die ook in de CBS_munics_hh zitten
# maak eerst juiste datatype van year_mun_id
tax$year_mun_id <- as.character(tax$year_mun_id)
CBS_munics_hh$year_mun_id <- as.character(CBS_munics_hh$year_mun_id)

tax_filtered <- tax[tax$year_mun_id %in% CBS_munics_hh$year_mun_id, ]
tax_filtered
```

```{r}
# Filter waar de inkomenskolom niet leeg is
income_columns = c('income_taxable', 'income_gross','income_unspecified', 'income_raad')
income_columns = c('income_taxable', 'income_gross','income_unspecified', 'tax', 'tax2', 'class_raad', 'income_raad', 'tax_raad', 'tax2_raad', 'tax_raad2')

# Keep rows with non-empty values in any of the income columns
tax_filtered_inc <- tax_filtered[rowSums(!is.na(tax_filtered[, income_columns])) > 0, ]
tax_filtered_inc
```

```{r}
unique(tax_filtered_inc$cbs_year)
year_mun_ids_with_refpop = CBS_munics_hh[CBS_munics_hh$refpop_proportional > 0, "year_mun_id"]

tax_filtered_ref = tax_filtered_inc[tax_filtered_inc$year_mun_id %in% year_mun_ids_with_refpop$year_mun_id, ]
unique(tax_filtered_ref$year_mun_id)
```

```{r}

```

## imputations (see Auke's script)

```{r}
rm(list = ls())

library("data.table")
library("arrow")
library("ineq")     # inequality measures and example data
library("EnvStats") # for estimation of censored distributions

source("impute.R") 

mypar = function(...){
    par(..., 
        bty = "l", 
        mar = c(4, 3, 2, 1), 
        mgp = c(1.7, .5, 0), 
        tck=-.01,
        font.main = 1)
}

tax = read_parquet("/Users/werk/Documents/git_hipnl/data/tax_records/tax_records_latest.parquet")
setDT(tax)

#tax = tax[place == "Harlingen" & year == 1889] not applicable bc all munics
y_trunc = na.omit(tax$income_taxable)

n_missing = c(m30 = 500, m40= 700, m50 = 1000, m60 = 1500, m70 = 2000, m80 = 3000)
1000 / (n_missing + 1000)

# naive estimates
ineq::Gini(y_trunc)
mean(log(y_trunc), na.rm = TRUE)
sd(log(y_trunc), na.rm = TRUE)

# each method, 6 n_missing, and for impute from subs. 3 subsistence estimate

# estimate_lnorm() uses EnvStats::enormCensored() to get unbiased mean and sd
# for the trunc. lognormal
sapply(n_missing, estimate_lnorm, y = y_trunc)

# impute_from_sd() uses the sd from the lognormal to estimate the Gini
impute_from_sd(y_trunc, n_missing[1])
toplot_from_sd = sapply(n_missing, impute_from_sd, y = y_trunc)

# sample_from_lognormal() uses the EnvStats::rnormTrunc() for random sample
# from truncated normal distribution, which is used to calculate the Gini

# list of samples
resampled = lapply(n_missing, sample_from_lognormal, y = y_trunc)
# gini on each sample in the list
toplot_resampled = sapply(resampled, ineq::Gini)

subsistence500 = lapply(n_missing, impute_from_subsistence, y = y_trunc, y_subsistence = min(y_trunc))
subsistence400 = lapply(n_missing, impute_from_subsistence, y = y_trunc, y_subsistence = 400)
subsistence300 = lapply(n_missing, impute_from_subsistence, y = y_trunc, y_subsistence = 300)

toplot500 = sapply(subsistence500, ineq::Gini)
toplot400 = sapply(subsistence400, ineq::Gini)
toplot300 = sapply(subsistence300, ineq::Gini)

xval = n_missing / (1000 + n_missing)
mypar(mfrow = c(1, 3))
yl = c(0.3, 0.8)
plot(xval, toplot_from_sd, type = "b", pch = 19, col = 2, 
    ylim = yl, 
    ylab = "Gini", xlab = "share missing", main = "Ïƒ-method")
abline(h = ineq::Gini(y_trunc), col = "gray")
plot(xval, toplot_resampled, type = "b", pch = 19, col = 2, 
    ylim = yl, 
    ylab = "Gini", xlab = "share missing", main = "Resampled lnorm")
abline(h = ineq::Gini(y_trunc), col = "gray")
plot(xval, toplot500, type = "b", pch = 19, col = 2, 
    ylim = yl, 
    ylab = "Gini", xlab = "share missing", main = "Hard-impute subsistence")
abline(h = ineq::Gini(y_trunc), col = "gray")
lines(xval, toplot400, type = "b", pch = 19, col = 3)
lines(xval, toplot300, type = "b", pch = 19, col = 4)
legend("topright", fill = 2:4, legend = c(500, 400, 300))
```

## impute lnorm and sd (idem impute.r)

```{r}
install.packages("EnvStats")
library("EnvStats") # for estimation of censored distributions

estimate_lnorm = function(y, n_missing){
    # take a truncated empirical distribution and estimate mean and sd as if it were lognormal
    # expects:
    #   y: the untransformed data
    #   n_missing: the expected number of missing observations
    censored = c(
        rep(FALSE, length(y)), 
        rep(TRUE, n_missing)
    )
    y = c(
        y, 
        rep(min(y, na.rm = TRUE), n_missing)
    )
    y = log(y)
    estimates = EnvStats::enormCensored(y, censored = censored, censoring.side = "left")
    return(list(
        log_mean = estimates$parameters["mean"], 
        log_sd = estimates$parameters["sd"]))
}

impute_from_sd = function(y, n_missing){
    # aitchison and brown gini from lnorm
    # expects
    #   y: the untransformed data
    #   n_missing: the expected number of missing observations

    parameters = estimate_lnorm(y, n_missing)
    sd_y = parameters$log_sd
    gini = 2*pnorm(sd_y / sqrt(2)) - 1

    return(gini)
}

sample_from_lognormal = function(y, n_missing){
    # fill NAs with resample from trunc lnorm
    # expects
    #   y: the untransformed data
    #   n_missing: the expected number of missing observations

    
    parameters = estimate_lnorm(y, n_missing)
    
    imputations = rnormTrunc(
        n = n_missing, 
        mean = parameters$log_mean, 
        sd = parameters$log_sd, 
        min = -Inf,
        max = min(log(y)))

    out = c(y, exp(imputations))
    
    return(out)
}

impute_from_subsistence = function(y, n_missing, y_subsistence){
    # fill NAs with subsistence incomes from X
    # tbd
     out = c(y, rep(y_subsistence, times = n_missing))

    return(out)
}
```
